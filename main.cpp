/************************************************************
source:
	C言語によるアルゴリズム辞典 p346
	
memo
	int fft(double x[], double y[], int IsReverse = FALSE);
		・標本点の数 "N"は2の階乗に限る
		・x[k]が実部、y[k]が虚部
		・結果はx[]、y[]に上書きする

	正直、内容についてはよく理解していない.
	本の内容をほぼそのまま写して動作確認しただけ.
************************************************************/

/************************************************************
************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/************************************************************
************************************************************/
static const int N = 64; // must be 2^x
static const double PI = 3.14159265398979;

double	sintbl[N + N/4];
int		bitrev[N];

/************************************************************
************************************************************/
int fft(double x[], double y[], int IsReverse = 0);
void make_bitrev(void);
void make_sintbl(void);


/************************************************************
************************************************************/

/******************************
******************************/
int main()
{
	/**************************
		x1[], y2[]に元となる波形を格納する
	**************************/
	int i;
	double x1[N], y1[N], x2[N], y2[N], x3[N], y3[N];

	for(i = 0; i < N; i++){
		// x1[i] = x2[i] = 6 * cos(6 * PI * i / N) + 4 * sin(18 * PI * i / N);
		x1[i] = x2[i] = sin( 1 * (2 * PI * i / N) ) + cos( 1 * (2 * PI * i / N) ) + sin( 5 * (2 * PI * i / N) ) - cos( 5 * (2 * PI * i / N) );
		
		y1[i] = y2[i] = 0;
	}

	/**************************
		初期化
	**************************/
	make_sintbl();
	make_bitrev();


	/**************************
		計算結果は、各時数のフーリエ係数 --- Excelで学ぶフーリエ変換で言う"Cn".
		x[]が実部、y[]が虚部

		Gain = 2 * sqrt(pow(x[], 2), pow(y[], 2));
		--- なぜ2倍が必要かはよくわからない.

		phase = atan(y[] / x[]);
	**************************/
	if(fft(x2, y2)) return 1;


	/**************************
		元に戻す.
	**************************/
	for(i = 0; i < N; i++){
		x3[i] = x2[i];
		y3[i] = y2[i];
	}
	if(fft(x3, y3, true)) return 1;


	/**************************
		Log.
	**************************/
	FILE* fp;
	fp = fopen("Log.csv", "w");
	if(fp == NULL){
		printf("File open Error\n");
		return 1;
	}
	for(i = 0; i < N; i++){
		fprintf(fp, "%d,%f,%f,,%d,%f,%f,,%d,%f,%f\n", i, x1[i], y1[i], i, x2[i], y2[i], i, x3[i], y3[i]);
	}
	fclose(fp);

	
	/**************************
		fin.
	**************************/
	printf("fin.\n");
	return 0;
}

/******************************
******************************/
int fft(double x[], double y[], int IsReverse)
{
	/*****************
		bit反転
	*****************/
	int i, j;
	for(i = 0; i < N; i++){
		j = bitrev[i];
		if(i < j){
			double t;
			t = x[i]; x[i] = x[j]; x[j] = t;
			t = y[i]; y[i] = y[j]; y[j] = t;
		}
	}

	/*****************
		変換
	*****************/
	int n4 = N / 4;
	int k, ik, h, d, k2;
	double s, c, dx, dy;
	for(k = 1; k < N; k = k2){
		h = 0;
		k2 = k + k;
		d = N / k2;

		for(j = 0; j < k; j++){
			c = sintbl[h + n4];
			if(IsReverse)	s = -sintbl[h];
			else			s = sintbl[h];

			for(i = j; i < N; i += k2){
				ik = i + k;
				dx = s * y[ik] + c * x[ik];
				dy = c * y[ik] - s * x[ik];

				x[ik] = x[i] - dx;
				x[i] += dx;

				y[ik] = y[i] - dy;
				y[i] += dy;
			}
			h += d;
		}
	}

	/*****************
	*****************/
	if(!IsReverse){
		for(i = 0; i < N; i++){
			x[i] /= N;
			y[i] /= N;
		}
	}

	return 0;
}

/******************************
******************************/
void make_bitrev(void)
{
	int i, j, k, n2;

	n2 = N / 2;
	i = j = 0;

	for(;;){
		bitrev[i] = j;
		if(++i >= N)	break;
		k = n2;
		while(k <= j)	{j -= k; k /= 2;}
		j += k;
	}
}

/******************************
******************************/
void make_sintbl(void)
{
	for(int i = 0; i < N + N/4; i++){
		sintbl[i] = sin(2 * PI * i / N);
	}
}
